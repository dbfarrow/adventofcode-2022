#!/usr/bin/env python3
import sys
sys.path.append('..')

from collections import defaultdict
import itertools
import re
from shared.aoc import __AOC
from shared import log

class Node():
    
    def __init__(self, data):

        p = 'Valve ([A-Z]+) has flow rate=([0-9]+); tunnels? leads? to valves? ([A-Z, ]+)'
        m = re.match(p, data)
        assert m != None, f'failed to parse: {data}'
    
        self.name = m.group(1)
        self.rate = int(m.group(2))
        self.neighbors = [ s.strip() for s in m.group(3).split(',') ]
        self.open = False

    def __repr__(self):
        return f'{self.name}: rate = {self.rate:02}; neighbors: {",".join(self.neighbors)}    '
        
class Path:

    def __init__(self, head):
        self.nodes = [ head ]
        self.released = 0

    def pathaddr(self):
        return '.'.join([ n.name for n in self.nodes ])

    def __repr__(self):
        return f'{self.released: 5}: {self.pathaddr()}'

    def add_node(self, node):
        return

def pathaddr(self):
    
    return '.'.join([ n.name for n in self.nodes ])

def next_path(nodes, parent, max_len):

    log.debug(f'next_path: parent: {parent}, max_len: {max_len}')
    log.debug(f'len(parent): {len(parent)}')
    p = parent[-1]
    ns = nodes[parent[-1]].neighbors
    log.debug(f'getting neighbors for {p}: {ns}')
    for n in ns:
        log.debug(f'p: {p}, n: {n}, max_len: {max_len}')
        parent.append(n)
        if len(parent) == max_len:
            log.warn('yielding')
            path = parent
            path.extend(n)
            return path
        else:
            log.warn(f'calling next_path with parent: {parent}')
            next_path(nodes, parent, max_len - 1)

    return None
   
class AOC(__AOC):

    def __init__(self):
        super().__init__(day=16) 

    def A(self):

        deadline = 30
        nodes = { n.name: n for n in [ Node(i) for i in self.get_input() ] }
        visited = []

        weights = [ 1, 2, 3]
        combos = itertools.permutations(weights, 3)
        for c in combos:
            log.info(c)

#       t = ppt = 0
#       path = []

#       p = [ 'AA' ]
#       for p in next_path(nodes, p, 3):
#           log.info(p)
#       return -1


#       return total

    def B(self):
        return None

if __name__ == "__main__":
    AOC().run()
